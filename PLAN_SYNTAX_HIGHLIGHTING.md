# Implementation Plan: Syntax Highlighting for ChatSH

## 1. Objective

Implement robust syntax highlighting for the `chatsh` CLI tool to improve readability of code blocks generated by the LLM. The implementation should mirror the aesthetic and behavior of the [OpenCode](../opencode) project where applicable, adapted for a terminal environment.

## 2. Reference Architecture (OpenCode)

The `opencode` project implements syntax highlighting using a combination of `marked` (Markdown parsing) and `shiki` (Syntax highlighting).

### Key Components

- **Configuration & Theme**: The core configuration is located in [marked.tsx](../opencode/packages/ui/src/context/marked.tsx).
  - It defines a custom Shiki theme named `"OpenCode"`.
  - Colors are mapped to CSS variables (e.g., `var(--syntax-keyword)`), allowing for dynamic theming.
  - It uses `marked-shiki` to integrate the highlighter into the markdown parsing pipeline.
- **Rendering**: The [Markdown.tsx](../opencode/packages/ui/src/components/markdown.tsx) component consumes the configured `marked` instance to render HTML.
- **Usage**: The [message-part.tsx](../opencode/packages/ui/src/components/message-part.tsx) component handles the display of different message parts (Text, Reasoning, Tool Outputs), ensuring all code blocks are passed through the markdown renderer.

## 3. Proposed Architecture (ChatSH)

Since `chatsh` runs in a terminal, we cannot output HTML. We must generate ANSI escape codes.

### Core Libraries

1.  **[shiki](https://shiki.style/)**: We will use `shiki` to tokenize code blocks.
2.  **[marked](https://marked.js.org/)**: To parse the incoming markdown stream/text.
3.  **[marked-terminal](https://github.com/mikaelbr/marked-terminal)** (or a custom renderer): To render Markdown tokens (headers, lists, bold, etc.) to ANSI.
    - _Note:_ Standard `marked-terminal` often uses `cardinal` for code. We will override this to use `shiki`.

### Strategy: Streaming vs. Buffered

The current `chatsh` implementation streams output directly to `stdout`.

- **Challenge**: Syntax highlighting usually requires the full code block (or at least a full line) to be accurate.
- **Solution**: Implement a **Buffered Stream Transformer**.
  1.  Pass normal text through immediately.
  2.  When a code block start fence (e.g., ` ```typescript `) is detected, **buffer** the output.
  3.  Continue buffering until the end fence (` ``` `) is detected.
  4.  Highlight the entire buffered block using `shiki` (converting tokens to ANSI colors).
  5.  Flush the highlighted block to `stdout`.
  - _Trade-off_: The user won't see the code type out character-by-character, but the block will appear instantly and fully highlighted once complete. This prevents "flickering" or incorrect highlighting during streaming.

### Theme Adaptation

We will port the "OpenCode" theme from [marked.tsx](../opencode/packages/ui/src/context/marked.tsx).

- Since the OpenCode theme uses CSS variables (e.g., `var(--syntax-keyword)`), we must map these variables to **ANSI colors** (or Hex codes supported by truecolor terminals).
- **Mapping Table**:
  - `--syntax-keyword` -> Magenta/Purple
  - `--syntax-string` -> Green
  - `--syntax-constant` -> Blue
  - `--syntax-comment` -> Gray
  - (and so on...)

## 4. Implementation Steps

### Step 1: Install Dependencies

Add the necessary packages to `copilot-scripts`.

```bash
bun add shiki marked marked-terminal chalk
```

### Step 2: Port the Theme

Create a new file `src/utils/theme.ts`.

- Copy the token colors from [marked.tsx](../opencode/packages/ui/src/context/marked.tsx).
- Replace the `var(--...)` values with hardcoded Hex values or calls to `chalk` functions suitable for a dark terminal theme.

### Step 3: Create the Renderer

Create `src/utils/markdown-renderer.ts`.

- Configure `marked` to use `marked-terminal`.
- Override the `code` renderer in `marked-terminal` options.
- Inside the `code` renderer:
  - Invoke `shiki.codeToAnsi(code, { lang, theme: 'OpenCode' })` (Note: `shiki` might need a helper to output ANSI, or we iterate tokens and apply `chalk`).
  - _Optimization_: `shiki` has a `codeToHtml` by default. We might need to use `shiki.codeToTokens` and map tokens to ANSI manually for best control.

### Step 4: Implement the Stream Buffer

Modify `src/tools/chatsh.ts`.

- Wrap the `onChunk` handler.
- Implement a simple state machine:
  - `STATE: TEXT` -> Print chars. If line starts with ` ``` `, switch to `STATE: CODE`.
  - `STATE: CODE` -> Buffer chars. If line is ` ``` `, process buffer, print, switch to `STATE: TEXT`.

## 5. Files for Context

- **Theme Definition**: [packages/ui/src/context/marked.tsx](../opencode/packages/ui/src/context/marked.tsx)
- **Markdown Component**: [packages/ui/src/components/markdown.tsx](../opencode/packages/ui/src/components/markdown.tsx)
- **Chat Message Rendering**: [packages/ui/src/components/message-part.tsx](../opencode/packages/ui/src/components/message-part.tsx)
